---
title: 排序
tags:
  - informatics
---
排序算法有很多，包括插入排序，冒泡排序，堆排序，归并排序，选择排序，计数排序，基数排序，桶排序，快速排序等。

| 排序算法 | 稳定性能 |      空间复杂度 | 平均时间复杂度 | 最差时间复杂度 |
| -------: | -------: | --------------: | -------------: | -------------: |
| 插入排序 |     稳定 |            O(1) |         O(n^2) |         O(n^2) |
| 冒泡排序 |     稳定 |            O(1) |         O(n^2) |         O(n^2) |
| 选择排序 |     稳定 |            O(1) |         O(n^2) |         O(n^2) |
| 快速排序 |   不稳定 | O(log(2n))~O(n) |   O(n*log(2n)) |         O(n^2) |
|   桶排序 |     稳定 |    O(n+n的长度) |   O(n+n的长度) |   O(n+n的长度) |
|   堆排序 |   不稳定 |            O(1) |     O(n*log2n) |     O(n*log2n) |
| 归并排序 |     稳定 |            O(n) |     O(n log n) |     O(n log n) |
| 基数排序 |     稳定 |      O(n的长度) |   O(n*n的长度) |   O(n*n的长度) |
| 希尔排序 |   不稳定 |            O(1) |              O |              O |

【1】插入排序：

简介：插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。
    
【2】冒泡排序：

简介：选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。
    
【3】选择排序：

简介：冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。
    
【4】快速排序：

简介：快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），简称快排，一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序个项目要（大O符号）次比较。在最坏状况下则需要次比较，但这种状况并不常见。事实上，快速排序通常明显比其他算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地达成。
```cpp
#include<cstdio>
int n,i,a[100000000]; 
void y(int ya,int yb){
	int y1=ya,y2=yb,y3=a[(ya+yb)/2];
	while(y1<=y2){
		while(a[y1]<y3)y1++;
		while(a[y2]>y3)y2--;
		if(y1<=y2){
			a[0]=a[y1];
			a[y1]=a[y2];
			a[y2]=a[0];
			y1++;
			y2--;
		}
	}
	if(y1<yb)y(y1,yb);
	if(ya<y2)y(ya,y2);
}
int main(){
	scanf("%d",&n);
	while(++i<=n)scanf("%d",&a[i]);
	y(1,n);
	for(i=1;i<=n;i++)printf("%d ",a[i]);
}
```
【5】桶排序

简介：桶排序,又名箱排序，英文名字为Bucket sort，是一种排序算法，工  作原理为将数组分到有限数量的桶子里。    桶排序是稳定的，且在大多数情 况下常见排序里最快之一。
    
【6】堆排序：

简介：堆排序（英语：Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。
    
【7】归并排序：

简介：归并排序法（Merge Sort，以下简称MS）是分治法思想运用的一个典范。其主要算法操作可以分为以下步骤： Step 1：将n个元素分成两个含n/2元素的子序列 Step 2：用MS将两个子序列递归排序（最后可以将整个原序列分解成n个子序列） Step 3：合并两个已排序好的序列 易知，MS的关键在于Merge过程。对于这一过程的理解，算法导论中给出了一个形象的模型。 即假设桌面上有两堆已排序好的的牌，且每一堆都正面朝下放置。然后我们分别从两堆牌中选取顶上的一张牌（选取之后，堆顶端又会露出新的顶牌），选取较小的一张，放入输出堆，另一张放回。 重复这一步骤，最后直到一堆牌为空。由于两堆牌都是已排序，所以可知，只要将剩下的那堆牌盖到输出堆即完成整个排序过程。
    
【8】基数排序：

简介：基数排序(radixsort）则是属于“分配式排序”（distributionsort），基数排序法又称“桶子法”（bucketsort）或binsort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O(nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的比较性排序法。基数排序的发明可以追溯到1887年赫尔曼·何乐礼在打孔卡片制表机(Tabulation Machine)上的贡献。
    
【9】希尔排序：

简介：希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的：插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率，但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位。
